#|
  Copyright (C) 2014 Reasoning Technology  All Rights Reserved.
  COMPANY CONFIDENTIAL Reaosning Technology
  author: thomas w. lynch
  
  2014-10-01 This file is being released under the GNU Lesser General Public License. 
  Please see the file ../doc/lpgl-3.0.txt for a copy of the license.

|#

#lang racket

;;--------------------------------------------------------------------------------
;; uses these libraries
;;    
  (require racket/match)
  (require (for-syntax racket/match))

  (require syntax/location)
  (require (for-syntax syntax/location))

  (require syntax/srcloc)
  (require (for-syntax syntax/srcloc))

  (require "test-lib.rkt")

  (require "arith-lib.rkt")
  (require (for-syntax "arith-lib.rkt"))

  (require "strings-etc.rkt")
  (require (for-syntax "strings-etc.rkt"))

  (require "sequence.rkt")
  (require (for-syntax "sequence.rkt"))

  (require (for-syntax racket/match))

  (require (for-syntax "location.rkt"))

  (require "name.rkt")
  (require (for-syntax "name.rkt"))
  (provide (all-from-out "name.rkt"))

;;--------------------------------------------------------------------------------
;;
  (define mc:λ-debug (make-parameter #t))
  (define-for-syntax mc:λ-debug (make-parameter #t))

;;--------------------------------------------------------------------------------
;;
;;  multiple continuation lambda, see docs for more details
;;
;;  need to implement var-args, right now the arg list is fixed length
;;
;;  three stages for mc:λ
;;     macro definition -- this is what you see here
;;     expansion -> returns a lambda defintion, this is when our macro runs
;;     call of the lambda
;;
;;  upon expansion our macro is given
;;    + an args list of identifiers and a conts list of identifiers
;;    + a list of expressions
;;  and returns a lambda
;;
;;  upon call the lambda is given
;;    + a list of values of the same arity as the args list,  a list of procedures of the same arity as the conts list
;;  lambda then calls one or more of the continuations
;;
  (define-syntax (mc:λ stx)
    (let(
          [datum  (syntax->datum stx)]
          [preamble (string-append
                      "generated by mc:λ macro defined at: " (source-location->string (quote-srcloc))
                      "\n"
                      "called at: " (source-location->string (source-location stx))
                      "\n "
                      )]
          )

      (cond
        [(length< datum 4) ;; check that datum has enough items
          (raise-syntax-error 
            #f
            "expected: (mc:λ args::Λ conts::Λ body::s-expr ...+)"
            stx
            )]
        [else 
          (name datum (macro-name args conts body ...)

            ;; look for syntax errors in the provided definition
            (define mess 
              (string-append
  
                (cond
                  [(not (pair? args)) 
                    " args must be a list with a first identifier for the args list name."
                    ]
                  [else
                    (apply string-append
                      (for/list(
                                 [a args]
                                 #:unless (symbol? a)
                                 )
                        (string-append " arg decl must be an identifier, but this is not: " (->string a) ".")
                        ))]
                  )

                (cond
                  [(not (pair? conts)) 
                    " conts must be a list with a first identifier for the conts list name."
                    ]
                  [(not (symbol? (car conts))) 
                    " first item in conts must be identifier for the conts list name."
                    ]
                  [else
                    (apply string-append 
                      (for/list(
                                 [c (cdr conts)]
                                 )
                        (if (not (and (pair? c) (length= c 2)))
                          (string-append 
                            " cont specifier must be an identifier followed by an arity. But found: "
                            (->string c)
                            "."
                            )
                          (string-append
                            (if (not (symbol? (car c))) 
                              (string-append " not an identifier: " (->string c) ".")
                              ""
                              )
                            (if (not (procedure-arity? (cadr c))) 
                              (string-append " not procedure arity: " (->string (cadr c)) ".")
                              ""
                              )
                            ))))
                    ]
                 )))

            (unless (string=? "" mess)
              (raise-syntax-error 
                #f
                mess
                stx
                ))

            (let(
                  [arg-list-name (car args)]
                  [arg-list (cdr args)]
                  [cont-list-name (car conts)]
                  [cont-list (map car (cdr conts))]
                  [cont-arities (map cadr (cdr conts))]
                  )
              (let(
                    [arg-cnt (length arg-list)]
                    [cont-cnt (length cont-list)]
                    [arg-arity-mess (string-append preamble " for the argument list")]
                    [conts-arity-mess (string-append preamble " for the continuations list")]
                    [cont-arity-mess (string-append preamble " continuation has wrong arity")]
                    )

              (let(
                    [program
                      `(λ (,arg-list-name ,cont-list-name)
                         ;; run time arity checks

                         (when (length≠ ,arg-list-name ,arg-cnt)
                           (raise-arity-error
                             'mc:λ
                             ,arg-arity-mess
                             ,arg-cnt
                             (length ,arg-list-name)
                             ))

                         (when (length≠ ,cont-list-name ,cont-cnt)
                           (raise-arity-error
                             'mc:λ
                             ,cont-arity-mess
                             ,cont-cnt
                             (length ,cont-list-name)
                             ))
                         (for(
                               [p ,cont-list-name]
                               [a ,cont-arities]
                               #:unless (equal? (procedure-arity? p) a)
                               )
                           (raise-arity-error
                             'mc:λ
                             (string-append ,cont-arity-mess " for continuation: " (->string p))
                             a
                             (procedure-arity? p)
                             ))

                         ;; now the program proper
                         (name ,arg-list-name ,arg-list
                           (name ,cont-list-name ,cont-list
                             ,@body
                             ))
                         )]
                    )
                (when (mc:λ-debug) (write (Λ "mc:λ -> " program)) (newline))
                (datum->syntax stx program)
                ))))])))

;;--------------------------------------------------------------------------------
;;
  (define (mc:λ-test-0)
    (define f (mc:λ (args x) (conts [cont-odd 0] [cont-even 0])
                (if (odd? x) (cont-odd) (cont-even))
                ))
    (define g (mc:λ (args x) (conts [cont-odd 0] [cont-even 0])
                (f args conts)
                ))
    (and
      (f (Λ 3) (Λ (λ()#t) (λ()#f)))
      (not (g (Λ 4) (Λ (λ()#t) (λ()#f))))
      ))
   (test-hook mc:λ-test-0)

;;--------------------------------------------------------------------------------
;;
  (provide
    mc:λ
    )
