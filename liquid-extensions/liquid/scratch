#|               

  (define (test-name-0)
    (define al '(1 2 3))
    (=
      (name al ([one 10] [two 20] [three 30]) (+ one two three))
      6
      ))
  (test-hook test-name-0)

  (define (test-name-1)
    (define al '(1 2 3))
    (equal?
      '(1 2 3)
      (name a1 (one two ...) (Λ one ,two))
      ))
  (test-hook test-name-1)

;;--------------------------------------------------------------------------------
;;
;;  multiple continuation lambda, see docs for more details
;;
;;  need to expand for var-args, right now the arg list is fixed length
;;
;;  three stages for mc:λ
;;     macro definition -- this is what you see here
;;     expansion -> returns a lambda defintion, this is when our macro runs
;;     call of the lambda
;;
;;  upon expansion our macro is given
;;    + an args list of identifiers and a conts list of identifiers
;;    + a list of expressions
;;  and returns a lambda
;;
;;  upon call the lambda is given
;;    + a list of values of the same arity as the args list,  a list of procedures of the same arity as the conts list
;;  lambda then calls one or more of the continuations
;;
  (define-syntax (mc:λ stx)
    (let(
          [datum  (syntax->datum stx)]
          [preamble (string-append
                         "generated by mc:λ defined at: " (->string (quote-srcloc))
                         " "
                         "called at: " (->string (quote-srcloc stx))
                         " "
                      )]
          )

      (cond
        [(length< datum 4) ;; check that datum has enough items
          (raise-syntax-error 
            #f
            "expected: (mc:λ args::Λ conts::Λ body::s-expr ...+)"
            stx
            )]
        [else 
          (name datum (Λ macro-name args conts body ...)

            ;; look for syntax errors in the provided definition
            (define mess 
              (string-append
                (cond
                  [(not (pair? args)) " args must be a list with a first identifier for the args list name"]
                  [else
                    (apply string-append
                      (for/list(
                                 [a args]
                                 #:unless (identifier? a)
                                 )
                        (string-append " arg decl must be an identifier, but this is not: " (->string a))
                        ))]
                  )

                (cond
                  [(not (pair? conts)) " conts must be a list with a first identifier for the conts list name"]
                  [(not (identifier? (car conts))) " first item in conts must be identifier for the conts list name"]
                  [else
                    (apply string-append
                      (for/list(
                                 [a (cdr conts)]
                                 )
                          (if (not (and (pair? a) (length= a 2)))
                            " cont specifiers must be an identifier followed by an arity"
                            (begin
                              (string-append
                                (when (not (identifier? (car c))) (string-append " not an identifier: " (->string c)))
                                (when (not (procedure-arity? (cadr c))) (string-append " not procedure arity: " (->string (cadr c))))
                                )))))]
                  )))
            (unless (string= "" mess)
              (raise-syntax-error 
                #f
                mess
                stx
                ))

            (let(
                  [arg-cnt (length (cdr args))]
                  [cont-cnt (length (cdr conts))]
                  [cont-arities (map cadr (cdr conts))]
                  [arg-arity-mess (string-append preamble " for the argument list")]
                  [conts-arity-mess (string-append preamble " for the continuations list")]
                  [cont-arity-mess (string-append preamble "continuation has wrong arity")]
                  )
              (let(
                    [program
                      `(λ (rt-args rt-conts)
                         ;; run time arity checks
                         (when (length≠ rt-args ,arg-cnt)
                           (raise-arity-error
                             'mc:λ
                             ,arg-artity-mess
                             ,arg-cnt
                             (length rt-args)
                             ))
                         (when (length≠ rt-conts ,cont-cnt)
                           (raise-arity-error
                             'mc:λ
                             ,cont-arity-mess
                             ,cont-cnt
                             (length rt-conts)
                             ))
                         (for(
                               [p rt-conts]
                               [a ,cont-arities]
                               #:unless (equal? (procedure-arity? p) a)
                               )
                           (raise-arity-error
                             'mc:λ
                             (string-append ,cont-arity-mess " for continuation: " (->string p))
                             a
                             (procedure-arity? p)
                             )))

                      ;; now the program proper
                      ,@body
                      )]
                )
              (when (mc:λ-debug) (write (Λ "mc:λ -> " program)) (newline))
              (datum->syntax stx program)
              )))

      

;;--------------------------------------------------------------------------------
;;
  (define (mc:λ-test-0)
    (define f (mc:λ (args x) (conts cont-odd cont-even)
                (if (odd? x) (cont-odd) (cont-even))
                ))
    (define g (mc:λ (args x) (conts cont-odd cont-even)
                (f args conts)
                ))
    (and
      (f (Λ 3) (Λ (λ()#t) (λ()#f)))
      (not (g (Λ 4) (Λ (λ()#t) (λ()#f))))
      ))

;;--------------------------------------------------------------------------------
;; initialize module
;;    
  (define (mc:λ:init)
    (test-hook test-name-0)
    (test-hook mc:λ-test-0)
    )
  (mc:λ:init)

|#
