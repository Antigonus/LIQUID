Just stated documenting these recently ...

1. 

  raco setup: 1 running: <pkgs>/liquid-doc/liquid/liquid.scrbl
  tabular: contract violation
    expected: list?
    given: "imperative:try"
    in: an element of
        the 1st argument of
        (->*
         ((listof
           (listof (or/c 'cont block? content?))))
         (#:cell-properties
          (listof (listof any/c))
          #:column-properties
          (listof any/c)
          #:row-properties
          (listof any/c)
          #:sep
          (or/c content? block? #f)
          #:style
          (or/c style? string? symbol? #f))
         table?)
    contract from: 
        <pkgs>/scribble-lib/scribble/base.rkt
    blaming: <pkgs>/liquid-doc/liquid/query-parser.scrbl
    at: <pkgs>/scribble-lib/scribble/base.rkt:349.2
    context...:
     /usr/share/racket/collects/racket/contract/private/blame.rkt:143:0: raise-blame-error16
     /usr/share/racket/collects/racket/contract/private/misc.rkt:496:9
     /usr/share/racket/collects/racket/contract/private/arrow-val-first.rkt:273:3
     /home/deep/liquid-doc/liquid/query-parser.scrbl: [running body]

2. in this one I have copied ap.rkt which is working in the liquid-example directory, over to a new directory so
that it can be modified into a different application.  I get an error with no line number for a refernce to
a file in the liquid-doc!   Not suprisingly grepping for webi-dblp.rkt yields nothing in the local code.  So
where the heck is this coming from???

  Welcome to Racket v6.1.
  racket@> (enter! "ap.rkt")
  get-module-code: no such file: #<path:/home/deep/liquid-doc/liquid/webi-dblp.rkt>
    context...:
     /usr/share/racket/collects/syntax/modcode.rkt:109:0: get-module-path51
     /usr/share/racket/collects/syntax/modcode.rkt:212:0: get-module-code79
     standard-module-name-resolver
     standard-module-name-resolver
     standard-module-name-resolver
     /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
     /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
     /usr/share/racket/collects/racket/private/misc.rkt:87:7


3. unknown identifiers are not so hard to find, unless created by a macro

racket@misc-lib.rkt> (enter! "db-lib.rkt")
(begin (require racket/trace) (define (db-lib-trace) (trace db-lib-init) (trace sql:exec) (trace sql:exec*) (trace sql:value) (trace sql:value*) (trace sql:maybe-value) (trace sql:maybe-value*) (trace sql:row) (trace sql:row*) (trace sql:rows) (trace sql:rows*) (trace sql:list) (trace sql:list*) (trace transaction:begin) (trace transaction:commit) (trace transaction:rollback) (trace column-list) (trace db:alloc-name) (trace db:alloc-number) (trace db:create-keyspace) (trace db:create-table) (trace db:delete-keyspace) (trace db:delete-table) (trace db:delete-table*) (trace db:is-keyspace) (trace db:is-table) (trace db:tables) (trace keyspace:alloc-number) (trace keyspace:dealloc-number) (trace table:delete) (trace table:insert) (trace table:insert*) (trace table:match)) (define (db-lib-untrace) (untrace db-lib-init) (untrace sql:exec) (untrace sql:exec*) (untrace sql:value) (untrace sql:value*) (untrace sql:maybe-value) (untrace sql:maybe-value*) (untrace sql:row) (untrace sql:row*) (untrace sql:rows) (untrace sql:rows*) (untrace sql:list) (untrace sql:list*) (untrace transaction:begin) (untrace transaction:commit) (untrace transaction:rollback) (untrace column-list) (untrace db:alloc-name) (untrace db:alloc-number) (untrace db:create-keyspace) (untrace db:create-table) (untrace db:delete-keyspace) (untrace db:delete-table) (untrace db:delete-table*) (untrace db:is-keyspace) (untrace db:is-table) (untrace db:tables) (untrace keyspace:alloc-number) (untrace keyspace:dealloc-number) (untrace table:delete) (untrace table:insert) (untrace table:insert*) (untrace table:match)) (provide db-lib-init) (provide sql:exec) (provide sql:exec*) (provide sql:value) (provide sql:value*) (provide sql:maybe-value) (provide sql:maybe-value*) (provide sql:row) (provide sql:row*) (provide sql:rows) (provide sql:rows*) (provide sql:list) (provide sql:list*) (provide transaction:begin) (provide transaction:commit) (provide transaction:rollback) (provide column-list) (provide db:alloc-name) (provide db:alloc-number) (provide db:create-keyspace) (provide db:create-table) (provide db:delete-keyspace) (provide db:delete-table) (provide db:delete-table*) (provide db:is-keyspace) (provide db:is-table) (provide db:tables) (provide keyspace:alloc-number) (provide keyspace:dealloc-number) (provide table:delete) (provide table:insert) (provide table:insert*) (provide table:match))
db-lib-init: unbound identifier in module
  in: db-lib-init
  context...:
   standard-module-name-resolver
   /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
   /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
   /usr/share/racket/collects/racket/private/misc.rkt:87:7

4.  say what? ... narrowed down to single module, never mind that module is 500 lines long .. went away after running
raco setup on the library again

racket@ap.rkt> (enter! "ap.rkt")
  [re-loading /home/deep/liquid-examples/test-ap/ap.rkt]
link: bad variable linkage;
 reference to a variable that is not a procedure or structure-type constant across all instantiations
  reference phase level: 0
  variable module: "/home/deep/liquid-lib/liquid/misc-lib.rkt"
  variable phase: 0
  reference in module: "/home/deep/liquid-lib/liquid/http-session.rkt"
  in: session-context-out
  context...:
   /home/deep/liquid-lib/liquid/http-session.rkt: [running body]
   /home/deep/liquid-examples/test-ap/ap.rkt: [traversing imports]
   /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
   /usr/share/racket/collects/racket/private/misc.rkt:87:7

5. so somewhere there is an application and that application is given a bad value.  Somewhere ...  It is a run
time error, and compiled languages will also do the same in such cases, i.e. no line numbers .. a function name maybe?
don't even know where this is called from.

racket@object.rkt> (obj-test-0)
application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 'field:copied-from
  arguments...: [none]
  context...:
   /home/deep/liquid-lib2/liquid/object.rkt:167:14
   /usr/share/racket/collects/racket/private/misc.rkt:87:7


6.  somewhere in the entirety of my program including the many requires, there is a call obj:set! with the wrong number of
arguments:

  racket@object.rkt> (enter! "node.rkt")
  obj:set!: arity mismatch;
   the expected number of arguments does not match the given number
    expected: 3
    given: 4
    arguments...:
     0
     9
     'field:debug
     "nd:type"
    context...:
     /home/deep/liquid-lib/liquid/node.rkt: [running body]
     /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
     /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
     /usr/share/racket/collects/racket/private/misc.rkt:87:7

7. somewhere in the file node.rkt, something doesn't like  variable that was defined, and provided from
object.rkt, complaining it is not a constant (why should it be??)  .. solution was to delete contents of
the 'compiled' directory

    racket@object.rkt> (enter! "node.rkt")
    link: bad variable linkage;
     reference to a variable that not constant
      reference phase level: 0
      variable module: "/home/deep/liquid-lib/liquid/object.rkt"
      variable phase: 0
      reference in module: "/home/deep/liquid-lib/liquid/node.rkt"
      in: type-type
      context...:
       /home/deep/liquid-lib/liquid/node.rkt: [running body]
       /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
       /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
       /usr/share/racket/collects/racket/private/misc.rkt:87:7


8.  this one took an hour, it is in docs  here is the error mess:


      §lambda1:/home/deep/liquid-doc/liquid> raco setup --pkgs liquid-doc
      raco setup: version: 6.1 [3m]
      raco setup: installation name: 6.1
      raco setup: variants: 3m
      raco setup: main collects: /usr/share/racket/collects
      raco setup: collects paths: 
      raco setup:   /home/mordecai/.racket/6.1/collects
      raco setup:   /usr/share/racket/collects
      raco setup: main pkgs: /usr/share/racket/pkgs
      raco setup: pkgs paths: 
      raco setup:   /usr/share/racket/pkgs
      raco setup:   /home/mordecai/.racket/6.1/pkgs
      raco setup: links files: 
      raco setup:   /usr/share/racket/links.rktd
      raco setup:   /home/mordecai/.racket/6.1/links.rktd
      raco setup: main docs: /usr/share/doc/racket
      raco setup: --- updating info-domain tables ---
      raco setup: --- pre-installing collections ---
      raco setup: --- installing foreign libraries ---
      raco setup: --- installing shared files ---
      raco setup: --- compiling collections ---
      raco setup: --- parallel build using 2 jobs ---
      raco setup: 1 making: <pkgs>/liquid-doc/compiled
      raco setup: 1 making: <pkgs>/liquid-doc/liquid
      raco setup: --- creating launchers ---
      raco setup: --- installing man pages ---
      raco setup: --- building documentation ---
      raco setup: 1 running: <pkgs>/liquid-doc/liquid/liquid.scrbl
      prog:3:0: read: expected a `)' to close `('
        possible cause: indentation suggests a missing `)' before line 7
        context...:
         /usr/share/racket/pkgs/scribble-lib/scribble/private/manual-code.rkt:56:0: typeset-code15
         /home/deep/liquid-doc/liquid/multiple-continuations-architecture.scrbl: [running body]
         /home/deep/liquid-doc/liquid/architecture.scrbl: [traversing imports]
         /home/deep/liquid-doc/liquid/liquid.scrbl: [traversing imports]
         /usr/share/racket/pkgs/racket-index/setup/scribble.rkt:895:0: load-doc/ensure-prefix
         /usr/share/racket/pkgs/racket-index/setup/scribble.rkt:1146:13
         /usr/share/racket/collects/setup/parallel-do.rkt:420:20: loop

problem is that it isn't in liquid.scrbl, it is in two include files down.  It is not
on line 7, but was well into the file, and it wasn't part of the document structure, but
it was in a quoted example ..  in multiple-continuations-architecture.scrbl:

      #lang scribble/manual
      @(require (for-label racket/base
                           ))               

      @title[#:style '(toc)]{Multiple Continuations Architecture}

      @section{The Basic Approach}

      As a matter of convention, we simplify function calls by not using variable arguments, but
      instead where variable arguments are required we use explicit lists.  We make this more
      convenient by introducing the Unicode capital lambda, Λ, as a synonym for @racket[list].
      In Emacs I have added both λ and Λ to my key map as alt-l  and alt-shift-l.

      Our basic approach is to pass continuation functions as arguments.  By convention the
      first function is the 'normal flow'.  By convention we call the first function
      continuation-ok.  For example, this is the definition for an extended hash ref that takes
      continuation functions.  It is implemented as a wrapper.  Of course it would be better to
      have a native version.

...


      @codeblock|{
        ...
        (define a 7)
        (x-hash-ref table a
          (λ(v) (display "found: ")(displayln v))
          (λ()  (displayln "did not find 7 ")  <---  scrble is mad this isn't balanced
          )
        ...
        }|

9.where in the file?

racket@> (enter! "object.rkt")
debug: undefined;
 cannot reference an identifier before its definition
  in module: 'extentions-lib
  phase: 1
  explanation: cannot access the run-time definition

10.  took 3 / 4 days to find this, ended up having to write a lot of special code for debugging
in racket, and develop the constructor technique ... an no the bug was not in obj:add-type as
indicated in the message, and certainly not on line 141.

  racket@> (enter! "object.rkt")
  ...
  (0.type-type)
  (obj:has-type 0 0)
  application: not a procedure;
   expected a procedure that can be applied to arguments
    given: 302
    arguments...:
     4
    context...:
     x-hash-ref
     /home/deep/liquid-lib/liquid/object.rkt:141:4: obj:add-type
     /home/deep/liquid-lib/liquid/object.rkt: [running body]
     /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
     /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
     /usr/share/racket/collects/racket/private/misc.rkt:87:7

11.mind telling me where in the f-in program the error occured?

  racket@object.rkt> (obj-test-1)
  =: contract violation
    expected: number?
    given: #f
    argument position: 1st
    other arguments...:
     12
    context...:
     /usr/share/racket/collects/racket/private/misc.rkt:87:7


I am really regretting using racket right now ... again ... no backtrace available

  "object.rkt"> ,bt
  ; =: contract violation
  ;   expected: number?
  ;   given: #f
  ;   argument position: 1st
  ;   other arguments...:
  ;    12
  ;   context...:
  ;    /usr/share/racket/pkgs/xrepl-lib/xrepl/xrepl.rkt:1380:0
  ;    /usr/share/racket/collects/racket/private/misc.rkt:87:7


12. this borders on being cruel .. back trace doesn't work

  "object.rkt"> (obj-test-1)
  (4.type:summable)
  (5.test-1-obj1)
  (6.test-1-obj2)
  (args type:summable + (test-1-obj1 test-1-obj2))
  (conts #<procedure> #<procedure> #<procedure>)
  (##  at  (/home/deep/liquid-lib/liquid/object.rkt 221 4))
  (--  expected length of 3 )
  (--  for:  (#<procedure>))
  ; uncaught exception: 'exception:check [,bt for context]
  "object.rkt"> ,bt
  ; uncaught exception: 'exception:check
  "object.rkt"> 


13.  because of require we don't even know what file this is in, and the message truncation was done by racket ...
so the first thing I had to do was load each require file ...

  Welcome to Racket v6.1.
  racket@> (enter! "object.rkt")
  displayln: contract violation
    expected: output-port?
    given: '(define (x-hash-ref args conts) (define mc:source-location '(x-hash-ref #<path:/home/deep/liquid-lib/liquid/extentions-lib.rkt> 293 4)) (if (check-mc:define-args-on-call "upon call of" mc:source-location args conts 2 2) (name args (table key) (name con...
    argument position: 2nd
    other arguments...:
     "mc:define -> "
    context...:
     /usr/share/racket/collects/racket/private/misc.rkt:178:4: displayln
     /home/deep/liquid-lib/liquid/extentions-lib.rkt:221:2
     /usr/share/racket/collects/syntax/wrap-modbeg.rkt:46:4
     standard-module-name-resolver
     standard-module-name-resolver
     standard-module-name-resolver
     /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
     /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
     /usr/share/racket/collects/racket/private/misc.rkt:87:7


14. you might think that a person could just look for the first summable in the module, but no, as that one
is well defined.   Indeed due to requires we can't even know which module this undefined summable occurs ..


  racket@object.rkt> (enter! "object.rkt")
    [re-loading /home/deep/liquid-lib/liquid/object.rkt]
  (mc:define ->  (define (get-elementary args conts) (define mc:source-location (quote (get-elementary /home/deep/liquid-lib/liquid/object.rkt 189 4))) (if (check-mc:define-args-on-call upon call mc:source-location args conts 2 2) (name args (objid type) (name conts (c0 c1) (x-hash-ref (Λ obj:tman-table objid) (Λ (λ (tman) (x-hash-ref (Λ tman type) conts)) (λ ignore-args (raise:no-such-object objid)))))) (raise (quote exception:mc:define-arity)))))
  (mc:define ->  (define (obj:set! args conts) (define mc:source-location (quote (obj:set! /home/deep/liquid-lib/liquid/object.rkt 200 4))) (if (check-mc:define-args-on-call upon call mc:source-location args conts 3 2) (name args (type objid Λfield-val) (name conts (continue-ok continue-no-type) (get-elementary (Λ objid type) (Λ (λ (e) (apply hash-set*! (cons e Λfield-val))) (λ ignore-args (continue-no-type args conts)))) (continue-ok objid))) (raise (quote exception:mc:define-arity)))))
  (mc:define ->  (define (obj:ref args conts) (define mc:source-location (quote (obj:ref /home/deep/liquid-lib/liquid/object.rkt 223 4))) (if (check-mc:define-args-on-call upon call mc:source-location args conts 3 3) (name args (type objid field) (name conts (continue-ok continue-no-field continue-no-such-type) (define (lookup-field-elementary e-obj) (define (lookup-field-indirect . ignored-args) (x-hash-ref e-obj field:copied-from (λ (objid-of-copied-from) (lookup-field-compound objid-of-copied-from)) (λ ignore-args (continue-no-field args conts)))) (when obj:debug (trace lookup-field-indirect)) (x-hash-ref (Λ e-obj field) (Λ continue-ok lookup-field-indirect))) (when obj:debug (trace lookup-field-elementary)) (define (lookup-field-compound objid) (get-elementary (Λ objid type) (Λ lookup-field-elementary (λ ignore-args (continue-no-such-type args conts))))) (when obj:debug (trace lookup-field-compound)) (lookup-field-compound objid))) (raise (quote exception:mc:define-arity)))))
  (mc:define ->  (define (obj:apply args conts) (define mc:source-location (quote (obj:apply /home/deep/liquid-lib/liquid/object.rkt 267 4))) (if (check-mc:define-args-on-call upon call mc:source-location args conts 3 3) (name args (type method-name method-args) (name conts (continue-ok continue-no-field continue-no-type) (when obj:debug (displayln (Λ obj:apply args: (obj:lookup type) method-name method-args)) (displayln (Λ obj:apply conts: continue-ok continue-no-field continue-no-type))) (obj:ref (Λ type-type type method-name) (Λ (λ (method-proc) (continue-ok (apply method-proc method-args))) (λ ignore-args (continue-no-field args conts)) (λ ignore-args (continue-no-type args conts)))))) (raise (quote exception:mc:define-arity)))))
  (name ->  (match-let (((list objid type) args)) (name conts (c0 c1) (x-hash-ref (Λ obj:tman-table objid) (Λ (λ (tman) (x-hash-ref (Λ tman type) conts)) (λ ignore-args (raise:no-such-object objid)))))))
  (name ->  (match-let (((list c0 c1) conts)) (x-hash-ref (Λ obj:tman-table objid) (Λ (λ (tman) (x-hash-ref (Λ tman type) conts)) (λ ignore-args (raise:no-such-object objid))))))
  (name ->  (match-let (((list type objid Λfield-val) args)) (name conts (continue-ok continue-no-type) (get-elementary (Λ objid type) (Λ (λ (e) (apply hash-set*! (cons e Λfield-val))) (λ ignore-args (continue-no-type args conts)))) (continue-ok objid))))
  (name ->  (match-let (((list continue-ok continue-no-type) conts)) (get-elementary (Λ objid type) (Λ (λ (e) (apply hash-set*! (cons e Λfield-val))) (λ ignore-args (continue-no-type args conts)))) (continue-ok objid)))
  (name ->  (match-let (((list type objid field) args)) (name conts (continue-ok continue-no-field continue-no-such-type) (define (lookup-field-elementary e-obj) (define (lookup-field-indirect . ignored-args) (x-hash-ref e-obj field:copied-from (λ (objid-of-copied-from) (lookup-field-compound objid-of-copied-from)) (λ ignore-args (continue-no-field args conts)))) (when obj:debug (trace lookup-field-indirect)) (x-hash-ref (Λ e-obj field) (Λ continue-ok lookup-field-indirect))) (when obj:debug (trace lookup-field-elementary)) (define (lookup-field-compound objid) (get-elementary (Λ objid type) (Λ lookup-field-elementary (λ ignore-args (continue-no-such-type args conts))))) (when obj:debug (trace lookup-field-compound)) (lookup-field-compound objid))))
  (name ->  (match-let (((list continue-ok continue-no-field continue-no-such-type) conts)) (define (lookup-field-elementary e-obj) (define (lookup-field-indirect . ignored-args) (x-hash-ref e-obj field:copied-from (λ (objid-of-copied-from) (lookup-field-compound objid-of-copied-from)) (λ ignore-args (continue-no-field args conts)))) (when obj:debug (trace lookup-field-indirect)) (x-hash-ref (Λ e-obj field) (Λ continue-ok lookup-field-indirect))) (when obj:debug (trace lookup-field-elementary)) (define (lookup-field-compound objid) (get-elementary (Λ objid type) (Λ lookup-field-elementary (λ ignore-args (continue-no-such-type args conts))))) (when obj:debug (trace lookup-field-compound)) (lookup-field-compound objid)))
  (name ->  (match-let (((list type method-name method-args) args)) (name conts (continue-ok continue-no-field continue-no-type) (when obj:debug (displayln (Λ obj:apply args: (obj:lookup type) method-name method-args)) (displayln (Λ obj:apply conts: continue-ok continue-no-field continue-no-type))) (obj:ref (Λ type-type type method-name) (Λ (λ (method-proc) (continue-ok (apply method-proc method-args))) (λ ignore-args (continue-no-field args conts)) (λ ignore-args (continue-no-type args conts)))))))
  (name ->  (match-let (((list continue-ok continue-no-field continue-no-type) conts)) (when obj:debug (displayln (Λ obj:apply args: (obj:lookup type) method-name method-args)) (displayln (Λ obj:apply conts: continue-ok continue-no-field continue-no-type))) (obj:ref (Λ type-type type method-name) (Λ (λ (method-proc) (continue-ok (apply method-proc method-args))) (λ ignore-args (continue-no-field args conts)) (λ ignore-args (continue-no-type args conts))))))
  summable: unbound identifier in module
    in: summable
    context...:
     /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
     /usr/share/racket/collects/racket/private/misc.rkt:87:7


so I have to search for all 'summable'   .. why doesn't the compiler tell me which one?  what is the big secret for?


15.  racket reports arity error, but does not say for which function ...  (turns out to be in obj:set! which I found
by walking through a trace).   line 421, which it cites, is simply the line of the define (obj-test-2) ... and something
is off in the weeds as the computer is crawling slow ...

  racket@object.rkt> (obj-test-2)
  >(obj:make "type:summable")
  (47.type:summable)
  <47
  >(obj:make "test-2-obj1")
  (48.test-2-obj1)
  <48
  >(obj:make "test-2-obj2")
  (49.test-2-obj2)
  <49
  >(obj:add-type 48 47)
  > (obj:is 47)
  < #t
  > (obj:is 48)
  < #t
  > (obj:has-type 48 47)
  > >(obj:is 47)
  < <#t
  > (x-hash-ref
     '(#hasheq((47 . #hasheqv())
               (46 . #hasheqv((46 . #hasheqv())))
               (49 . #hasheqv())
               (48 . #hasheqv()))
       48)
     '(#<procedure> #<procedure>))
  > >(be #t)
  < <#<procedure:beit>
  > >(be #f)
  < <#<procedure:beit>
  > (x-hash-ref '(#hasheqv() 47) '(#<procedure:beit> #<procedure:beit>))
  < #f
  > (x-hash-ref
     '(#hasheq((47 . #hasheqv())
               (46 . #hasheqv((46 . #hasheqv())))
               (49 . #hasheqv())
               (48 . #hasheqv()))
       48)
     '(#<procedure> #<procedure>))
  < #<void>
  <48
  >(obj:add-type 49 47)
  > (obj:is 47)
  < #t
  > (obj:is 49)
  < #t
  > (obj:has-type 49 47)
  > >(obj:is 47)
  < <#t
  > (x-hash-ref
     '(#hasheq((47 . #hasheqv())
               (46 . #hasheqv((46 . #hasheqv())))
               (49 . #hasheqv())
               (48 . #hasheqv((47 . #hasheqv()))))
       49)
     '(#<procedure> #<procedure>))
  > >(be #t)
  < <#<procedure:beit>
  > >(be #f)
  < <#<procedure:beit>
  > (x-hash-ref '(#hasheqv() 47) '(#<procedure:beit> #<procedure:beit>))
  < #f
  > (x-hash-ref
     '(#hasheq((47 . #hasheqv())
               (46 . #hasheqv((46 . #hasheqv())))
               (49 . #hasheqv())
               (48 . #hasheqv((47 . #hasheqv()))))
       49)
     '(#<procedure> #<procedure>))
  < #<void>
  <49
  #<procedure>: arity mismatch;
   the expected number of arguments does not match the given number
    expected: 2
    given: 3
    arguments...:
     47
     49
     '(x 21)
    context...:
     /home/deep/liquid-lib/liquid/object.rkt:421:0: obj-test-2
     /usr/share/racket/collects/racket/private/misc.rkt:87:7
  racket@object.rkt> 

16.

  racket@kw.rkt> (with-db (current-example-db) (db:alloc-name))
  lifted.0.3: undefined;
   cannot reference an identifier before its definition
    in module: "/home/deep/liquid-lib/liquid/kw.rkt"
    context...:
     /usr/share/racket/collects/racket/private/misc.rkt:87:7


  §lambda1:/home/deep/liquid-lib/liquid> grep lifted *.rkt

  §lambda1:/home/deep/liquid-lib/liquid>


17.

  racket@kw.rkt> (enter! "kw.rkt")
    [re-loading /home/deep/liquid-lib/liquid/kw.rkt]
  _: wildcard not allowed as an expression
    in: _
  racket@kw.rkt> 


18.

    reloading a module does nothing, which is nice in that why load a
    module that has already been loaded ... however, this means that
    module state does not get reset on a second or later load by redoing
    the load!

    also had problems where load of a module that uses another module
    where that second module has been changed, does not reload the second
    module (because it is called from a first module that has not changed) 

19.  doesn't even tell which function the error came from, let alone a source line number

      line 851 is the entry point (semantic-relation:lookup-ids-test-1) , which doesn't
      take arguments, sort is called in multiple places ... which one?

    racket@dataplex-lib.rkt> (semantic-relation:lookup-ids-test-1)
    <: contract violation
      expected: real?
      given: '(1 4 7 10)
      argument position: 1st
      other arguments...:
       '(1 7 10)
      context...:
       /usr/share/racket/collects/racket/private/sort.rkt:213:0: sort
       /home/deep/liquid-lib/liquid/dataplex-lib.rkt:851:4: semantic-relation:lookup-ids-test-1
       /usr/share/racket/collects/racket/private/misc.rkt:87:7
    racket@dataplex-lib.rkt> 

20. typical case, error is where?

    racket@kw.rkt>   (define (display-sm an-sm)
        (with-db (current-example-db)
          (let*(
                 [t0 (semantic-relation:match dp-ex1 R1 '_)] ; returns a list of rows, each row item is a singleton sp value
                 [t1  (map (λ(row)(map (λ(item)(car item)) row))  t0)] ; strips parens off of the singleton row items
                 )
            (map (λ(row)displayln(row)) t1) ;; <----- error on this line
            )))

    racket@kw.rkt> (display-sm R1)
    application: not a procedure;
     expected a procedure that can be applied to arguments
      given: '("k1" "c1")
      arguments...: [none]
      context...:
       stdin::739: display-sm
       /usr/share/racket/collects/racket/private/misc.rkt:87:7
    racket@kw.rkt> display-sm
    #<procedure:display-sm>


    and tried at the prompt, the error goes away:

    racket@kw.rkt>   (define (display-sm an-sm)
        (with-db (current-example-db)
          (let*(
                 [t0 (semantic-relation:match dp-ex1 R1 '_)] ; returns a list of rows, each row item is a singleton sp value
      ;;           [t1  (map (λ(row)(map (λ(item)(car item)) row))  t0)] ; strips parens off of the singleton row items
                 [t1 '()]
                 )
            (map (λ(row)displayln(row)) t1) 
            )))
    racket@kw.rkt> (display-sm R1)
    '()
    racket@kw.rkt> t0
    '((("k1") ("c1")) (("c2") ("c3")))
    racket@kw.rkt> (map (λ(row)(map (λ(item)(car item)) row))  t0)
    '(("k1" "c1") ("c2" "c3"))
    racket@kw.rkt> (define t1  (map (λ(row)(map (λ(item)(car item)) row))  t0))


21.  never mind the fact that this identifier dosn't appear in this file ...  if it is created by a
     macro, then which macro?  which invocation of the macro?

    Process Racket REPL finished
    Welcome to Racket v6.1.
    racket@> (enter! "kw.rkt")
    shape-relation:values:index-by-sp-id: unbound identifier in module
      in: shape-relation:values:index-by-sp-id
    racket@> 

22.

    racket@> (enter! "extentions-lib.rkt")
    when: bad syntax
      in: (when else-flag)
      context...:
       standard-module-name-resolver
       /usr/share/racket/collects/racket/rerequire.rkt:18:0: rerequire
       /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
       /usr/share/racket/collects/racket/private/misc.rkt:87:7
    racket@> 


23. ok ... so there is an error somewhere in the module having to do with redefining test-Λ-0


   racket@sequence-lib.rkt> (enter! "sequence-lib.rkt")
     [re-loading /home/deep/liquid-lib/liquid/sequence-lib.rkt]
   (wrap test:  #f)
   (wrap test:  #f)
   (wrap test:  #f)
   hooking test: test-unwrap
   define-values: assignment disallowed;
    cannot re-define a constant
     constant: test-Λ-0
     in module: "/home/deep/liquid-lib/liquid/sequence-lib.rkt"
     context...:
      /home/deep/liquid-lib/liquid/sequence-lib.rkt: [running body]
      /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
      /usr/share/racket/collects/racket/private/misc.rkt:87:7


problem is, this is the only occurance of that identifier in the module:

  ;; does the job of list
  (define (test-Λ-0)
    (equal? '(1 2 3) (Λ 1 2 3))
    )
  (test-hook test-Λ-0)

24 ...  the provide syntax suffers from the same drawback as header files - we end up with two edits to make
for modifying a function prototype


25.  errors is actually somewhere in extensions-lib.rkt, presumably in one of the many wrap calls, will
trace wrap .. oh, can't do that as this fails on load ..  line 157 in sequence-lib is first line of wrap,
so there is no hint as to where in wrap this problem occurs (or where wrap was called from).


    racket@extentions-lib.rkt> (enter! "extentions-lib.rkt")
      [re-loading /home/deep/liquid-lib/liquid/extentions-lib.rkt]
    cdr: contract violation
      expected: pair?
      given: 'Λ
      context...:
       /home/deep/liquid-lib/liquid/sequence-lib.rkt:157:2
       /usr/share/racket/collects/racket/enter.rkt:54:0: dynamic-enter!6
       /usr/share/racket/collects/racket/private/misc.rkt:87:7

... problem turned out to be in the cond/list program in extentions-lib.rkt, (define seq-op Λ) was supposed
to be (define seq-op 'Λ).   found by stubbing out the program and bring pieces to life one by one.
