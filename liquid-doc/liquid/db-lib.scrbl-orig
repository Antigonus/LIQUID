

#lang scribble/manual

@title{db-lib}

@section{Introdcution}

   db-lib is a layer over rackets db library.  

   db-lib is written specifically to be used as a generic persistent store for predicates
   used in the LIQUID library.  Hence, a number of simplifications are possible.

   We do not expect users of LIQUID to call these functions, but instead to use the databplex
   layer that goes yet above this layer.  See dataplex.rkt.  

   db-lib is intended to be threadsafe but testing of this aspect has been limited, and there
   is a known bug in nesting transaction blocks due to how thread semaphores are used.

@section{function nameing convention}

  Function names are prefixed according to the domain in which the function is working.  For
  example, functions that work on the dataase as an object are prefixed 'db:',  while those
  that work on table as objects are prefixed 'table:'.  This approach alleviated a great deal of
  confusion and some name collissions that existed before the convention was adopted.

@section{Shared Connection}

  Currently this interface is intialized against a single database connection.  In the next version
  I plan for a connection context through a 'with-connection'  block or some such.  In any case
  no connection parameter appears on the databae manipulation calls.

@section{All Table Columns are Text}

  In the db-lib all table columns are text type.  Text is the only readily available arbitrary
  length SQL object. Scheme serializes into text.   Hence text can provide a bridge between an
  SQL database and Scheme.  

  Conversion, if any, is done on the client side.  Some of the db calls accept filter functions
  that facilitate conversion.

  Scheme numbers are arbitrary lage, but all SQL numbers are limited in size.  Even the big
  int in the SQL is fixed size (though it may be very large).  Hence we use text for
  numbers as well. 

  Because we represent numbers in text form there is only one system of arthmetic used on
  numbers, that of Racket Scheme.  As alphabetization provides order for string results
  from numeric conversion, the SQL database can still create indexes, sort, and search. 
  As 64 bits numbers are now eight bytes long, and conversions are arleady done to get
  numbers into SQL - I wonder if what if any sort of performance loss this causes.

@section{namespace}

  In the db-lib an allocator is an object for creating unique numbers or unique names.  A
  programmer may use the db-lib to create any number of such objects.  Each allocator has a
  string bound to it.  We also call allocators 'namespaces'.  Allocators are persistent (held
  in the database).

  A user of the db-lib may use the allocator service for any purpose he or she desires to.
  One applications has been in creating unique names and numbers when testing.

  The db-lib creates a namespace with the same name as each table that is created.  It then
  uses this namespace to assign a unique number to each and every row.  The first column
  of every table holds such a row id.

  Numbers in namespace may be deallocated.  Currently we do not recycle deallocated numbers,
  but this may change in later versions.

  See lynch-lib's (unique-to-session-number) and (unique-to-session-name) for unique values within a
  session. Note, unique numbers to the session may not be unique to the database.

  We reserve the namespace 'unique_to_db' for global allocation. 


@subsection{namespace:alloc-number}

        (namespace:alloc-number namespace)

        Accepts a namespace and returns a unique number within that namespace.  See also db:create-namespace.

@subsection{namespace:dealloc-number}

        (namespace:dealloc-number namespace id)


@section{sql}

These are wrappers for the underlying db library.  They only difference is that they act on the
default connection. The * versions take lists, the others take variable parameters lists.  These are intended
to be used only as work arounds.  In a later version they may go away.

      sql:exec
      sql:exec*
      sql:value
      sql:value*
      sql:maybe-value
      sql:maybe-value*
      sql:row
      sql:row*
      sql:rows
      sql:rows*
      sql:list
      sql:list*

      transaction:begin
      transaction:commit
      transaction:rollback

@section{as-transaction}

        (as-transaction body ...)

        This provides a scoped context for a transaction block.

        (There is a current a bug affecting nesting of transactions blocks having to do with
        locking out other threads on the same connection ... priority issue, may hang when
        nested)


@section{db}

@subsection{db:tables}

      (db:tables [rx #f])

      Accepts a regular expression. Returns a list of matching tables names.


@subsection{db:is-table)

        (db:is-table table-name)

        Accepts a table name, returns a bool.


@subsection{db:table db:table*)

        (db:delete-table . ts)  (db:delete-table* ts)

        Deletes the named tables.  The table names are literal.

@subsection{db:create-table}

        (db:create-table name column-count)

        Accepts a name and a columen count, then creates a table in the database with that name
        and number of columns, or throws an exception.   Returns nothing.

        An exception will occur if the name already
        exists as a table in the database.  

@subsection{db:delete-table db:delete-table*}
@subsection{etc.}
    db:alloc-number
    db:alloc-name

    db:create-namespace
    db:delete-namespace
    db:is-namespace

@section{table}
@subsection{table:insert table:insert*}

    (table:insert name . rows) 
    (table:insert* name rows) 

@subsection{table:delete}

        (table:delete table-name a-pattern)

    Accepts a table name and a pattern, then deletes all rows from the table that
    match the pattern.

    If the table has more than one column, pattern must be a list.  Currently pattern
    is either an underscore or a literal.  An underscore matches anything.

@subsection(table:match}

    (table:match table-name pattern [a-filter identity])

    Accepts a table name, a pattern, and optionally a filter function.  Returns all
    rows in the table that match the pattern.  If the filter is present then the filter
    is mapped over the rows to create the return value.





